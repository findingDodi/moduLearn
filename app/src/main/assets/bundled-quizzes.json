[
  {
    "title": "Grundlagen der Programmierung",
    "description": "Willkommen zum Quiz über das Thema „Grundlagen der Programmierung“!",
    "questions": [
      {
        "question_text": "Was definiert ein Datentyp?",
        "answer_options": [
          "Den Namen einer Variable.",
          "Den Wertebereich, der gespeichert werden kann.",
          "Die Operationen, die auf einen Wert möglich sind."
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": [
          1,
          2
        ],
        "explanation": "Damit die CPU immer das 'Richtige' mit den 'richtigen Sachen macht, wird durch einen Datentyp festgelegt, was das 'Richtige' ist. Ein Datentyp definiert somit, welche Wertebereich gespeichert werden kann und welche Operationen auf diesem Wert möglich sind."
      },
      {
        "question_text": "Welche der folgenden Datentypen ist nicht in Java vorhanden?",
        "answer_options": [
          "int",
          "double",
          "float",
          "decimal"
        ],
        "type": "SINGLE_CHOICE",
        "answer": [
          3
        ],
        "explanation": "Datentypen für Fließkommazahlen sind 'float' und 'double'."
      },
          {
            "question_text": "Was ist der Unterschied zwischen einer Ganzzahl (int) und einer Fließkommazahl (double) in Java?",
            "answer_options": [
              "Eine Ganzzahl ist eine ganze Zahl ohne Dezimalstellen, während eine Fließkommazahl eine Zahl mit Dezimalstellen ist.",
              "Eine Ganzzahl ist größer als eine Fließkommazahl.",
              "Eine Ganzzahl kann negative Werte haben, während eine Fließkommazahl nur positive Werte haben kann."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Es gibt mehrere Datentypen für Zahlen aufgrund der ökonomischen Nutzung des Speichers. Dabei unterscheidet man Datentypen für ganze Zahlen (byte, short, int, long) und Datentypen für Fließkommazahlen (float, double)."
          },
          {
            "text": "Welchen Wertebereich hat der primitive Datentyp 'short' in Java?",
            "options": [
              "-128 bis 127",
              "0 bis 65535",
              "-32768 bis 32767"
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Ein Byte besitzt den Wertebereich von -128 bis 127. Der zweite Wertebereich gehört zu keinen Datentypen, da immer positive und negative Werte abgedeckt werden."
          },
          {
            "text": "Was ist ein Referenz-Datentyp in Java?",
            "options": [
              "Ein Datentyp, der primitive Werte enthält.",
              "Ein Datentyp, der auf Objekte verweist.",
              "Ein Datentyp, der zur Speicherung von Texten verwendet wird."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Eine Variable von einem Referenz-Datentyp beinhaltet den Verweis auf den eigentlichen Wert im Speicher, anstelle des Wertes selbst. Dabei kann es sich z.B. um einen String zur Speicherung von Texten handeln."
          },
          {
            "text": "Welche Zuweisungen sind erlaubt?",
            "options": [
              "byte -> short",
              "short -> int",
              "long -> float"
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              1,
              2
            ],
            "explanation": "Einer Variablen eines Zahlen-Datentyp kann man dann einen Wert eines anderen Zahlen-Datentyps zuweisen, wenn dabei keine 'Platzprobleme' im Speicher entstehen. Das heißt Zuweisungen von 'kleineren' Zahlenwerten in 'größere' Zahlen-Variablen sind erlaubt."
          },
          {
            "text": "Welcher primitive Datentyp wird in Java für Wahrheitswerte verwendet?",
            "options": [
              "boolean",
              "int",
              "double"
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Eine Variable des Datentyps boolean kann genau zwei Werte annehmen: true oder false. Dieser dient beispielsweise zur Speicherung der Ergebnisse von logischen Operationen."
          },
          {
            "text": "Was besagt das Schisser-Prinzip?",
            "options": [
              "Einer Variable eines Zahlen-Datentyp kann man nie einen Wert eines anderen Zahlendatentyps zuweisen.",
              "Einer Variable eines Zahlen-Datentyp kann man immer einen Wert eines anderen Zahlendatentyps zuweisen.",
              "Der Compiler gibt bereits eine Fehlermeldung, wenn es möglich ist, dass ein Datenverlust stattfindet."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Das Schisser-Prinzip erlaubt es, dass Fehlerquellen frühzeitig gefunden werden können."
          }
        ]
      },
      {
        "title": "Variablen",
        "questions": [
          {
            "text": "Welche Konventionen gibt es in Java bei der Benennung von Variablen?",
            "options": [
              "Variablen müssen mit einem Großbuchstaben beginnen.",
              "Variablennamen sollten aussagekräftig sein und aus mehreren Wörtern bestehen, die aus mit Hilfe von CamelCase zusammengesetzt werden.",
              "Variablennamen sollten möglichst kurz sein und am besten nur Abkürzungen sein.",
              "Variablennamen sollten nur aus Zahlen bestehen."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Der Name einer Variable sollte ein gut-beschreibender Bezeichner sein. Dabei gilt, dass er aus beliebig vielen Buchstaben, Ziffern und Underscores bestehen darf, sofern er nicht mit einer Ziffer beginnt und kein reserviertes Wort enthält."
          },
          {
            "text": "Wie werden Variablen in Java definiert?",
            "options": [
              "Variablen müssen mit dem Schlüsselwort 'var' deklariert werden.",
              "Variablen müssen mit dem Datentyp und einem Bezeichner (Namen) deklariert werden.",
              "Variablen müssen mit dem Schlüsselwort 'let' deklariert werden."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Syntax: <datentyp> <name>; \n Beispiel: int my_number;"
          },
          {
            "text": "Was ist Strong-Typing?",
            "options": [
              "Ein Konzept, bei dem Variablen ohne explizite Typisierung verwendet werden können.",
              "Ein Konzept, bei dem Variablen verschiedene Datentypen gleichzeitig annehmen können.",
              "Ein Konzept, bei dem Variablen bei der Deklaration einen Datentyp erhalten und dieser während der Laufzeit des Programms nicht geändert werden kann."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Strong-Typing gehört zum Schisser-Prinzip und stellt somit sicher, dass Fehlerquellen frühzeitig gefunden werden können."
          },
          {
            "text": "Welche Vorteile hat Strong-Typing in der Programmierung?",
            "options": [
              "Erhöhung der Lesbarkeit und Verständlichkeit des Codes, Verbesserung der Codequalität.",
              "Erhöhung der Geschwindigkeit und Effizienz des Programms, Verkürzung der Entwicklungszeit.",
              "Erkennung von Fehlern zur Kompilierzeit.",
              "Es gibt kein Strong-Typing."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              2
            ],
            "explanation": "Strong-Typing beschreibt das Konzept der frühen und starken Datentyp-Prüfung und unterstützt daher das Schisser-Prinzip."
          },
          {
            "text": "Welcher Operator wird in Java verwendet, um den Wert einer Variable zu ändern?",
            "options": [
              "=",
              "==",
              "!="
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Der Operator '=' wird verwendet, um einer Variablen einen (neuen) Wert zuzuweisen."
          },
          {
            "text": "Welche Zustände kann eine Referenz-Variable annehmen?",
            "options": [
              "Nicht initialisiert",
              "null",
              "Eine Referenz"
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              1,
              2
            ],
            "explanation": "Eine Referenz-Variable kann nicht 'nicht initialisiert' sein, sonst kommt es zu einer Fehlermeldung. Abhilfe schafft hier der Zustand 'null', der bedeutet, dass die Referenz noch 'unbekannt' ist."
          }
        ]
      }
    ]
  },
  {
    "title": "Prozeduren und Funktionen",
    "description": "Willkommen zum Quiz über das Thema „Prozeduren und Funktionen“!",
    "quizzes": [
      {
        "title": "Prozeduren",
        "questions": [
          {
            "text": "Was ist eine Prozedur?",
            "options": [
              "Ein Datentyp.",
              "Eine Methode, die keinen Rückgabewert hat.",
              "Eine Methode, die einen Wert zurückgibt."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Methoden sind ein benannter, abrufbarer Code-Abschnitt. Dabei unterscheidet man zwischen Funktionen, die einen Wert am Ende zurückgeben und Prozeduren, die keinen Wert zurückgeben."
          },
          {
            "text": "Wie definiert man eine Prozedur in Java?",
            "options": [
              "Mit dem Schlüsselwort 'function'.",
              "Mit dem Schlüsselwort 'void'.",
              "Mit dem Schlüsselwort 'return'."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Void ist der Datentyp einer Prozedur."
          },
          {
            "text": "Wie ruft man eine Prozedur in Java auf?",
            "options": [
              "Mit dem Schlüsselwort 'call'.",
              "Mit dem Namen der Prozedur und eventuellen Argumenten in geschweiften Klammern.",
              "Mit dem Schlüsselwort 'run'.",
              "Mit dem Namen der Prozedur und eventuellen Argumenten in runden Klammern."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              3
            ],
            "explanation": "Syntax: <name>();"
          },
          {
            "text": "Was gehört zur Signatur einer Prozedur?",
            "options": [
              "Die Rückgabetypen einer Prozedur.",
              "Der Name einer Prozedur.",
              "Die Dokumentation einer Prozedur.",
              "Die Parameterliste einer Prozedur."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              1,
              3
            ],
            "explanation": "Die Signatur einer Prozedur setzt sich zusammen aus dem Namen und der Parameterliste."
          },
          {
            "text": "Was ist Javadoc?",
            "options": [
              "Eine Programmiersprache.",
              "Ein Dokumentationswerkzeug für Java-Code.",
              "Eine Entwicklungsumgebung für Java."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Javadoc ein vorgeschriebenes Format zur Beschreibung von Java-Code."
          },
          {
            "text": "Wie sieht die Javadoc-Syntax aus?",
            "options": [
              "Der Block-Kommentar beginnt mit '*'.",
              "Der Block-Kommentar beginnt mit '/*'.",
              "Der Block-Kommentar beginnt mit '/**'.",
              "Tags werden mit einem '@' begonnen."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              2,
              3
            ],
            "explanation": "Der Javadoc-Kommentar wird mit einem '/**' begonnen, darauf folgt eine Beschreibung, was gemacht werden soll und schließlich folgt die Auflistung der Tags."
          }
        ]
      },
      {
        "title": "Funktionen",
        "questions": [
          {
            "text": "Was ist eine Funktion?",
            "options": [
              "Ein Datentyp.",
              "Eine Methode, die keinen Rückgabewert hat.",
              "Eine Methode, die einen Wert zurückgibt."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Methoden sind ein benannter, abrufbarer Code-Abschnitt. Dabei unterscheidet man zwischen Funktionen, die einen Wert am Ende zurückgeben, und Prozeduren, die keinen Wert zurückgeben."
          },
          {
            "text": "Wie definiert man eine Funktion in Java?",
            "options": [
              "Mit dem Schlüsselwort 'void'.",
              "Mit dem Schlüsselwort 'function'.",
              "Mit dem Rückgabetypen und dem Namen der Funktion."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Bei der Definition von Funktionen wird der Datentyp des Werts angegeben, der am Ende zurückgegeben wird. Genau wie bei Prozeduren, bekommt eine Funktion einen Namen."
          },
          {
            "text": "Wie ruft man eine Funktion in Java auf?",
            "options": [
              "Mit dem Namen der Funktion und eventuellen Argumenten in runden Klammern.",
              "Mit dem Namen der Funktion und eventuellen Argumenten in geschweiften Klammern.",
              "Mit dem Schlüsselwort 'call'.",
              "Mit dem Schlüsselwort 'run'."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Syntax: <name>(); \n Der beim Aufruf ausgegebene Wert kann in einer Variable des passenden Datentyps gespeichert und anschließend verwendet werden."
          },
          {
            "text": "Was ist der Unterschied zwischen einer Funktion und einer Prozedur?",
            "options": [
              "Eine Funktion hat keinen Rückgabewert, aber eine Prozedur schon.",
              "Eine Prozedur hat keinen Rückgabewert, aber eine Funktion schon.",
              "Eine Funktion kann nicht aufgerufen werden.",
              "Es gibt keinen Unterschied."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Methoden sind ein benannter, abrufbarer Code-Abschnitt. Dabei unterscheidet man zwischen Funktionen, die einen Wert am Ende zurückgeben, und Prozeduren, die keinen Wert zurückgeben."
          },
          {
            "text": "Was sind formale Parameter in einer Funktion?",
            "options": [
              "Die Parameter, die bei Aufruf der Funktion übergeben werden.",
              "Die Parameter, die beim Definieren  der Funktion im Code angegeben."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Beim Aufruf einer Funktion werden innerhalb der Klammern die aktuellen Parameter angegeben. Diese Werte werden dann überall dort im Funktionsablauf verwendet, wo die formalen Parameter stehen."
          },
          {
            "text": "Was gehört zur Signatur einer Funktion?",
            "options": [
              "Die Parameterliste einer Funktion.",
              "Die Dokumentation einer Funktion.",
              "Der Name einer Funktion."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              2
            ],
            "explanation": "Die Signatur einer Funktion setzt sich zusammen aus dem Namen und der Parameterliste."
          },
          {
            "text": "Was ist der Zweck des Überladens von Funktionen?",
            "options": [
              "Die Vermeidung von Namenskonflikten.",
              "Die Erhöhung der Lesbarkeit von Code.",
              "Die Möglichkeit, eine Funktion mit verschiedenen Argumenttypen zu definieren."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Es ist möglich, Funktionen bzw. Prozeduren mit dem gleichen Namen zu definieren, sofern sie sich beim Aufruf durch die Parameterliste eindeutig voneinander unterscheiden."
          },
          {
            "text": "Was sind rekursive Funktionen?",
            "options": [
              "Funktionen, die sich selbst aufrufen.",
              "Funktionen, die auf eine spezielle Art und Weise definiert sind.",
              "Funktionen, die nur in bestimmten Fällen ausgeführt werden."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Rekursive Funktionen sind eine 'elegantere' Vorgehensweise für rekursive Probleme, die über das mehrfache Ausführen einer Funktion über eine Schleife gelöst werden."
          },
          {
            "text": "Was gilt für die Benennung von Funktionen?",
            "options": [
              "Der Name drückt aus, was getan werden soll.",
              "Der Name drückt aus, was das Ergebnis ist.",
              "Bei einer Funktion, die einen booleschen Wert zurückgibt, wird der erfragte Zustand als Name verwendet."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              1,
              2
            ],
            "explanation": "Anders als bei Prozeduren, gibt der Name einer Funktion nicht an, was getan werden soll, sondern was das Ergebnis ist."
          }
        ]
      }
    ]
  },
  {
    "title": "Konzept der Objektorientierung",
    "description": "Willkommen zum Quiz über das Thema „Objektorientierung“!",
    "quizzes": [
      {
        "title": "OOP Einführung & Konzepte",
        "questions": [
          {
            "text": "Was sind Vorteile von objektorientierter Programmierung?",
            "options": [
              "Mehr Wiederverwendbarkeit von Code.",
              "Bessere Strukturierung von Code.",
              "Einfachere Fehlerbehebung.",
              "Man kann von überall auf die Daten zugreifen."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              1,
              2
            ],
            "explanation": "In objektorientierten Programmiersprache werden Daten und Funktionalitäten zu Objekten verbunden, ihre Eigenschaften werden in Klassen beschrieben."
          },
          {
            "text": "Was versteht man unter Kapselung?",
            "options": [
              "Daten und Methoden sind über eine Schnittstelle zugänglich.",
              "Implementierungsdetails werden in einer Klasse verborgen.",
              "Mittels Gettern und Settern kann man immer auf Daten zugreifen."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              1
            ],
            "explanation": "Die Kapselung ist Teil des DOOM-Konzepts. Dabei gilt, dass der Zugriff auf die Eigenschaften eines Objekts streng geregelt wird, mit anderen Worten: sie werden gekapselt."
          },
          {
            "text": "Was besagt das DOOM-Prinzip?",
            "options": [
              "Der Zugriff auf Daten eines Objektes geschieht über die Methoden des Objektes.",
              "Man hat von außen Zugriff auf die Daten eines Objektes.",
              "Zwischen Daten und Methoden eines Objekts besteht keine Verknüpfung.",
              "Zusammengehörige Daten und Methoden bilden eine Einheit."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              3
            ],
            "explanation": "Das DOOM-Konzept besagt, dass die Daten und Methoden eines Objekts eng miteinander verknüpft sind. Der Zugriff wird durch die Kapselung streng reguliert: Methoden können von außen aufgerufen werden, wohingegen die Daten verborgen bleiben. Stattdessen läuft der Zugriff auf die Daten über die Methoden ab."
          },
          {
            "text": "Welche Vorgehensweise entspricht dem OO-Konzept?",
            "options": [
              "Der Zugriff auf Eigenschaften eines Objekts läuft über öffentliche Variablen.",
              "Das Objekt wird beauftragt, etwas mit Daten zu tun.",
              "Beide Vorgehensweisen entsprechen dem OO-Konzept."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Der OO-Ansatz beschreibt die Vorgehensweise, dass man das Objekt beauftragt etwas mit seinen Daten zu tun (über Methoden), statt direkt auf die Daten von außen zuzugreifen."
          },
          {
            "text": "Was ist eine Klasse?",
            "options": [
              "Eine Sammlung von Objekten.",
              "Ein Datentyp zur Definition gleichartiger Objekte.",
              "Die Instanz eines Objekts."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Eine Klasse beschreibt die gemeinsamen Eigenschaften gleichartiger Objekte, sie ist also ein Datentyp. Die Instanz einer Klasse wird Objekt genannt."
          },
          {
            "text": "Was ist ein Objekt?",
            "options": [
              "Eine Sammlung von Klassen.",
              "Eine Instanz einer Klasse.",
              "Eine Methode in einer Klasse."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Ein Objekt ist die Instanz einer Klasse und besitzt somit alle Eigenschaften dieser Klasse."
          },
          {
            "text": "Was sind IVs?",
            "options": [
              "IV steht für Instanz Variablen und bezieht sich auf Variablen, die in einer Methode definiert sind.",
              "IV steht für Instanz Variablen und bezieht sich auf die Daten eines Objekts.",
              "IV steht für Integer Variables und bezieht sich auf Variablen, die mit ganzzahligen Werten arbeiten."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Instanz-Variablen (IVs) sind die Daten eines Objekts und werden in einer Klasse definiert. Jede Instanz dieser Klasse besitzt dann eine solche Variable."
          },
          {
            "text": "Was sind IMs?",
            "options": [
              "IM steht für Instanz Methoden und bezieht sich auf Methoden, die direkt auf Objekte angewendet werden können.",
              "IM steht für Instanz Methoden und bezieht sich auf Methoden, die direkt auf Klassen angewendet werden können.",
              "IM steht für Integer Methods und bezieht sich auf Methoden, die mit ganzzahligen Werten arbeiten."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Instanz-Methoden (IMs) sind die Prozeduren und Funktionen eines Objekts und werden in einer Klasse definiert. Innerhalb der IMs kann nun auf die IVs zugegriffen werden, um den Zweck der Methode zu erfüllen. "
          }
        ]
      }
    ]
  },
  {
    "title": "Klassen und Objekte",
    "description": "Willkommen zum Quiz über das Thema „Klassen und Objekte“!",
    "quizzes": [
      {
        "title": "Konstruktoren",
        "questions": [
          {
            "text": "Was ist ein Constructor?",
            "options": [
              "Eine Methode, die aufgerufen wird, um ein Objekt zu erzeugen.",
              "Eine Methode, die verwendet wird, um den Zugriff auf eine Klasse zu steuern.",
              "Eine Methode, die die Vererbung von Eigenschaften zwischen Klassen ermöglicht."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Ein Konstruktor ist eine besondere Art von Methoden, die für die allgemeine Initialisierung eines Objekts verwendet wird. Ein Konstruktor wird ohne Rückgabetyp definiert, ist aber auch nicht vom Typ void. Er wird ausschließlich nach dem Schlüsselwort 'new' oder innerhalb eines anderen Konstruktors aufgerufen."
          },
          {
            "text": "Was ist das 'Armenrecht' in Bezug auf Constructor?",
            "options": [
              "Der Compiler ergänzt immer automagically einen Default-Constructor mit leerem Body.",
              "Der Compiler ergänzt automagically einen Default-Constructor mit leerem Body, wenn kein Constructor explizit definiert wird.",
              "Der Compiler ergänzt automagically einen Konstruktor mit einem Standardparameter."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Der automagically eingefügte Konstruktor dient der Bequemlichkeit und verkürzt den Code. Allerdings liegt dadurch auch eine häufige Fehlerquelle vor."
          },
          {
            "text": "Wofür kann man Konstruktoren überladen?",
            "options": [
              "Das Überladen ermöglicht, mehrere Konstruktoren zu definieren, die unterschiedliche Namen haben.",
              "Das Überladen ermöglicht, den gleichen Konstruktor für verschiedene Klassen zu definieren.",
              "Das Überladen ermöglicht, verschiedene Konstruktoren zu definieren, die unterschiedliche Parameter akzeptieren."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Genau wie bei Prozeduren und Funktionen ist es möglich, mehrere Konstruktoren zu definieren, die sich in den Parametern, die sie akzeptieren unterscheiden."
          },
          {
            "text": "Wofür wird this innerhalb eines Konstruktors verwendet?",
            "options": [
              "this referenziert die zuletzt definierte Variable.",
              "this referenziert den Konstruktor.",
              "this referenziert das Ziel-Objekt.",
              "this() führt zum Aufruf eines anderen Konstruktors der gleichen Klasse."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              2,
              3
            ],
            "explanation": "Mit this wird das Ziel-Objekt, das heißt das neu-erzeugte Objekt, referenziert. Wenn ein anderer Konstruktor der aktuellen Klasse aufgerufen werden soll, kann this() verwendet werden."
          },
          {
            "text": "Welche Vorgehensweise ist richtig?",
            "options": [
              "Kleinere Konstruktoren rufen Größere auf.",
              "Größere Konstruktoren rufen Kleinere auf.",
              "Es sollte immer nur den Default-Konstruktor in einer Klasse geben."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Um Konstruktoren innerhalb eines Konstruktors der gleichen Klasse aufzurufen, wird zunächst ein 'größerer' definiert, welchem die Werte für mehrere bzw. alle IVs übergeben werden. Wenn nun weitere Konstruktoren implementiert werden, werden nicht in diesen selbst die IVs gesetzt, stattdessen wird der 'größere' Konstruktor mittels this() aufgerufen."
          }
        ]
      },
      {
        "title": "Klassenvariablen",
        "questions": [
          {
            "text": "Was ist eine Klassenvariable?",
            "options": [
              "Eine Variable, die der Klasse selbst zugeordnet ist.",
              "Eine Variable, die von jedem Objekt der Klasse geteilt wird.",
              "Eine Variable, die nur von einer Methode innerhalb der Klasse genutzt werden kann.",
              "Eine Variable, die nur innerhalb des Konstruktors der Klasse genutzt werden kann."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              1
            ],
            "explanation": "Im Gegensatz zu Instanz-Variablen sind Klassen-Variablen der Klasse selbst zugeordnet und somit unabhängig von den Instanzen dieser Klasse. Sie kommt nur ein einziges Mal vor und wird auch statische Variable genannt."
          },
          {
            "text": "Wie kann auf eine Klassenvariable zugegriffen werden?",
            "options": [
              "Durch den Aufruf einer Instanzmethode der Klasse.",
              "Durch den Aufruf einer Klassenmethode der Klasse.",
              "Durch den direkten Zugriff auf die Variable durch die Klasse."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Syntax: <klassen_name>.<variablen_name> \n Beispiel: StudiCV.laufendeNummer"
          },
          {
            "text": "Welches Schlüsselwort wird genutzt, um eine Klassenvariable zu deklarieren?",
            "options": [
              "private",
              "public",
              "static"
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Syntax: <access_modifier> static <datentyp> <variablen_name>; \n Beispiel: private static int laufendeNummer;"
          },
          {
            "text": "Was ist der Unterschied zwischen einer Instanzvariable und einer Klassenvariable?",
            "options": [
              "Eine Instanzvariable ist statisch und wird von der gesamten Klasse geteilt, während eine Klassenvariable an ein spezifisches Objekt gebunden ist.",
              "Eine Instanzvariable ist an ein spezifisches Objekt gebunden, während eine Klassenvariable von jedem Objekt der Klasse geteilt wird.",
              "Eine Instanzvariable kann nur innerhalb der Klasse genutzt werden, während eine Klassenvariable von außerhalb der Klasse genutzt werden kann."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Instanzvariablen sind abhängig von einer Instanz. Klassenvariablen sind der Klasse selbst zugeordnet."
          },
          {
            "text": "Können Klassenvariablen geerbt werden?",
            "options": [
              "Ja, sie werden automatisch an alle Subklassen vererbt.",
              "Nein, Klassenvariablen können nicht vererbt werden."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Statische Eigenschaften werden vererbt und stehen somit in den Subklassen zur Verfügung. Sie existieren jedoch auch weiterhin nur ein einziges Mal."
          },
          {
            "text": "Welches Schlüsselwort wird genutzt, um eine Konstante zu deklarieren?",
            "options": [
              "final",
              "static",
              "const"
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              1
            ],
            "explanation": "Syntax: static final <datentyp> <variablen_name> \n Beispiel: static final String IBAN_PREFIX = 'DE"
          },
          {
            "text": "Wann werden Konstanten verwendet?",
            "options": [
              "Sie werden genutzt, um Werte fest zu definieren, die während der Laufzeit des Programms nicht verändert werden können.",
              "Sie dienen dazu, Variablen innerhalb einer Klasse zu speichern.",
              "Sie werden verwendet, um Methoden innerhalb einer Klasse aufzurufen."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Konstanten besitzen einen Wert, der nur einmal gesetzt wird und danach nicht mehr geändert werden kann. Daher werden sie als Klassenvariable definiert."
          }
        ]
      },
      {
        "title": "Klassenmethoden",
        "questions": [
          {
            "text": "Was sind Klassenmethoden?",
            "options": [
              "Methoden, die nur von Objekten einer Klasse aufgerufen werden können.",
              "Methoden, die nur innerhalb einer Klasse aufgerufen werden können.",
              "Methoden, die direkt von der Klasse aufgerufen werden können."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Im Gegensatz zu Instanz-Methoden sind Klassen-Methoden der Klasse selbst zugeordnet und somit unabhängig von den Instanzen dieser Klasse. Die Methode soll also funktionieren, ohne dass dafür ein Objekt vorhanden ist."
          },
          {
            "text": "Wie wird eine Klassenmethode außerhalb der Klasse aufgerufen?",
            "options": [
              "Über eine Objektinstanz der Klasse",
              "Mit dem Klassennamen gefolgt von einem Punkt und dem Methodennamen.",
              "Mit dem Methodennamen gefolgt von einem Punkt und dem Klassennamen."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Syntax: <klassen_name>.<methoden_name>(); \n Beispiel: StudiCM.zufaelligerString()"
          },
          {
            "text": "Wie wird eine Klassenmethode innerhalb der Klasse aufgerufen?",
            "options": [
              "Mit dem Methodennamen.",
              "Mit dem Klassennamen gefolgt von einem Punkt und dem Methodennamen.",
              "Mit dem Methodennamen gefolgt von einem Punkt und dem Klassennamen."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              1
            ],
            "explanation": "Innerhalb der Klasse ist die Angabe des Klassennamens beim Aufruf optional."
          },
          {
            "text": "Welche Aussagen sind korrekt?",
            "options": [
              "In Klassenmethoden kann man this verwenden.",
              "In Klassenmethoden kann man this nicht verwenden.",
              "this referenziert in Klassenmethoden die Klasse selbst.",
              "this führt in Klassenmethoden zu einem Fehler."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              3
            ],
            "explanation": "Da Klassen-Methoden unabhängig von Objekten der Klasse sind, gibt es auch kein Ziel-Objekt, das von this referenziert wird. Somit führt die Verwendung von this zu einem Fehler."
          },
          {
            "text": "Welches Schlüsselwort wird verwendet, um eine Klassenmethode zu definieren?",
            "options": [
              "this",
              "super",
              "static"
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Mit dem Schlüsselwort static können Variablen und Methoden zu Klassenvariablen und Klassenmethoden werden"
          },
          {
            "text": "Können Klassenmethoden private sein?",
            "options": [
              "Ja, aber sie können dann nur innerhalb der Klasse aufgerufen werden.",
              "Nein, Klassenmethoden müssen immer public sein."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Syntax: <access_modifier> static <datentyp> <methoden_name>() {...}; \n Beispiel: public static String zufaelligerString() {...};"
          },
          {
            "text": "Werden Klassenmethoden an Subklassen vererbt?",
            "options": [
              "Ja, Klassenmethoden stehen auch in den Subklassen bereit.",
              "Nein, Klassenmethoden werden nicht vererbt."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Statische Eigenschaften werden vererbt und stehen somit in den Subklassen zur Verfügung."
          }
        ]
      }
    ]
  },
  {
    "title": "Vererbung",
    "description": "Willkommen zum Quiz über das Thema „Vererbung“!",
    "quizzes": [
      {
        "title": "Vererbung",
        "questions": [
          {
            "text": "Was ist der Nutzen von Vererbung?",
            "options": [
              "Vererbung ermöglicht das Wiederverwenden von Code und die Reduzierung von Redundanz.",
              "Vererbung erhöht die Komplexität von Klassen und erschwert die Wartbarkeit von Code.",
              "Vererbung ist nur bei sehr speziellen Anwendungsfällen sinnvoll."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Gemeinsame Eigenschaften mehrere Klassen sollen nur 1x in einer Klasse definiert werden und in allen Klassen bereitstehen. Dies wird durch das Vererbungskonzept ermöglicht."
          },
          {
            "text": "Was ist die is_a Beziehung?",
            "options": [
              "Eine Beziehung zwischen einer Superklasse und einer Subklasse.",
              "Eine Beziehung zwischen Objekten verschiedener Klassen.",
              "Eine Beziehung zwischen einem Attribut und einem Objekt."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "'<subtyp> is_a <supertyp>' ist die formale Ausdrucksweise, um das Verhältnis zwischen einer Superklasse und einer Subklasse anzugeben."
          },
          {
            "text": "Was besagt das Substitutions-Prinzip?",
            "options": [
              "Objekte einer Superklasse können an Stelle von Objekten der Subklasse verwendet werden.",
              "Objekte einer Subklasse können an Stelle von Objekten der Superklasse verwendet werden."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Das Substitutions-Prinzip gründet auf dem Schisser-Prinzip. Hier wird sichergestellt, dass alle Methoden-Aufrufe für die Variable auch nach der Zuweisung noch funktionieren müssen, das heißt, dass das Objekt, das nun referenziert wird, mindestens alle Eigenschaften des vorherigen Objekts besitzen muss. Dies trifft auf alle Objekte der Subklasse zu."
          },
          {
            "text": "Was ist die Rolle der Klasse 'Object' in der Vererbungshierarchie?",
            "options": [
              "Sie ist eine spezielle Klasse, die nur von der Java Virtual Machine verwendet wird.",
              "Sie ist eine Klasse, die nur von fortgeschrittenen Programmierern verwendet wird.",
              "Sie ist die Klasse, von der alle anderen Klassen abgeleitet werden."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Object ist die Mutter aller Klasse und die Default-Superklasse. Wenn bei der Definition einer Klasse keine Superklasse angegeben wird, ist die Klasse also automatisch Superklasse. Somit ist jeder Typ (in)direkt von Object abgeleitet."
          },
          {
            "text": "Was ist ein UML-Diagramm?",
            "options": [
              "Ein Diagramm, das den Datenfluss innerhalb eines Programms darstellt.",
              "Ein Diagramm, das die Struktur und Verhaltensweise von Klassen und Objekten in einem System darstellt."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "UML ist kurz für 'Unified Modeling Language'."
          },
          {
            "text": "Wie werden Subklassen in Java definiert?",
            "options": [
              "Mit dem Schlüsselwort 'inherits'.",
              "Mit dem Schlüsselwort 'extends'.",
              "Mit dem Schlüsselwort 'implements'.",
              "Mit dem Schlüsselwort 'abstract'."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Syntax: public class <name> extends <superklasse> {...} \n Beispiel: public class Kreis extends Form {...}"
          },
          {
            "text": "Wie wird der Constructor der Superklasse aufgerufen?",
            "options": [
              "Mittels 'superconstructor()'.",
              "Mittels 'this()'.",
              "Mittels 'super()'."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Allgemein gilt, dass jede Klasse selbst für ihre IVs verantwortlich ist. Somit muss im Konstruktor einer Subklasse dafür gesorgt werden, dass ein Konstruktor der Superklasse aufgerufen wird. Der Compiler erzeugt automagically einen Aufruf von super() als erste Zeile, es sei denn, dort steht bereits ein Aufruf eines Konstruktors der Superklasse."
          }
        ]
      },
      {
        "title": "Interfaces",
        "questions": [
          {
            "text": "Was ist der Nutzen von Interfaces?",
            "options": [
              "Sie erlauben die Mehrfachvererbung in Java.",
              "Sie definieren eine Schnittstelle, die von Klassen implementiert werden kann, um bestimmte Methoden bereitzustellen.",
              "Sie sind eine alternative Möglichkeit, um abstrakte Klassen zu definieren.",
              "Sie werden verwendet, um private Methoden in Klassen zu definieren."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              1
            ],
            "explanation": "In Java kann eine Klasse immer nur von einer Superklasse erben, wohingegen mehrere Interfaces implementiert werden können."
          },
          {
            "text": "Wie werden Interfaces in Java definiert?",
            "options": [
              "Mit dem Schlüsselwort 'class'.",
              "Mit dem Schlüsselwort 'interface'.",
              "Mit dem Schlüsselwort 'implements'.",
              "Mit dem Schlüsselwort 'abstract'."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Syntax: <access_modifier> interface <interface_name> {...}"
          },
          {
            "text": "Wie werden Methoden in einem Interface automatisch definiert?",
            "options": [
              "private",
              "private abstract",
              "public",
              "public abstract"
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              3
            ],
            "explanation": "Methoden eines Interfaces werden automatisch als public abstract definiert, da der Zugriff von außen möglich sein soll und kein Body notwendig ist."
          },
          {
            "text": "Welche Art von Variablen kann in einem Interface definiert werden?",
            "options": [
              "Private Variablen",
              "Public Variablen",
              "Static Final Variablen",
              "Private und Public Variablen"
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Interfaces besitzen keine Instanz-Variablen, aber es ist möglich statische Konstanten zu definieren."
          },
          {
            "text": "Was sind Default Methoden in einem Interface?",
            "options": [
              "Methoden, die automatisch von jeder Klasse, die das Interface implementiert, überschrieben werden müssen.",
              "Methoden, die in einer Implementierungsklasse überschrieben werden können, aber nicht müssen.",
              "Methoden, die in einem Interface nicht definiert werden dürfen.",
              "Methoden, die keinen Body besitzen"
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Neben abstrakten Methoden, können auch Default-Methoden definiert werden, die einen Body besitzen. Dadurch wird Code-Duplikation in den Subtypen vermieden."
          },
          {
            "text": "Wie wird ein Interface implementiert?",
            "options": [
              "Mit dem Schlüsselwort 'class'.",
              "Mit dem Schlüsselwort 'interface'.",
              "Mit dem Schlüsselwort 'implements'.",
              "Mit dem Schlüsselwort 'extends'."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Syntax: class <klassen_name> implements <interface_name>"
          },
          {
            "text": "Was ist der Unterschied zwischen einer abstrakten Klasse und einem Interface?",
            "options": [
              "Abstrakte Klassen können nicht implementiert werden, aber Interfaces schon.",
              "Abstrakte Klassen können Variablen und Methoden implementieren, aber Interfaces nicht.",
              "Interfaces erlauben Mehrfachvererbung, abstrakte Klassen nicht.",
              "Abstrakte Klassen erlauben Mehrfachvererbung, aber Interfaces nicht."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "In Java kann eine Klasse immer nur von einer Superklasse erben, ganz gleich, ob diese abstrakt oder nicht-abstrakt ist. Interfaces bieten dahingegen eine Möglichkeit der Mehrfachvererbung."
          },
          {
            "text": "Welche Aussage zu Variablen in einem Interface ist korrekt?",
            "options": [
              "Variablen in einem Interface dürfen keinen Wert besitzen.",
              "Variablen in einem Interface sind automatisch static final.",
              "Es gibt keine Variablen in einem Interface."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Variablen sind immer static final, da ein Interface nur statische Konstanten besitzen darf."
          },
          {
            "text": "Welche Aussage zu Interfaces und Vererbung ist korrekt?",
            "options": [
              "Interfaces können nur von anderen Interfaces erben.",
              "Interfaces können von anderen Interfaces und Klassen erben.",
              "Wenn eine Superklasse ein Interface implementiert, implementieren auch alle Subklassen das Interface.",
              "Wenn eine Superklasse ein Interface implementiert, gilt das nicht für die Subklassen."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              2
            ],
            "explanation": "Interfaces können nur von anderen Interfaces erben, nicht von Klassen. Die Implementierung von Interfaces wird mit vererbt."
          },
          {
            "text": "Was gilt für eine Klasse K, die ein Interface I implementiert?",
            "options": [
              "Die Klasse K wird zu einem Subtyp des implementierten Interfaces I.",
              "Das Interface wird zu einem Subtyp der implementierenden Klasse.",
              "K is_a I.",
              "I is_a K."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              2
            ],
            "explanation": "'<subtyp> is_a <supertyp>' ist die formale Ausdrucksweise, um das Verhältnis zwischen einem Supertyp und einem Subtyp anzugeben."
          }
        ]
      },
      {
        "title": "Abstrakte Klassen",
        "questions": [
          {
            "text": "Wofür werden abstrakte Klassen verwendet?",
            "options": [
              "Sie dienen als Vorlage für spezifische Klassen.",
              "Sie dienen dazu, eine Klasse instanziierbar zu machen.",
              "Sie dienen dazu, die Vererbungshierarchie zu vereinfachen.",
              "Sie unterscheiden sich nicht von anderen Klassen."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Eine abstrakte Klasse ist eine Klasse, die nicht instanziiert werden kann und als Superklasse für spezifischere Klassen genutzt wird."
          },
          {
            "text": "Wie wird eine abstrakte Klasse definiert?",
            "options": [
              "class MyClass",
              "public abstract class MyClass",
              "abstract class MyClass",
              "abstract MyClass"
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              1,
              2
            ],
            "explanation": "Syntax: <access_modifier> abstract class <klassen_name> {...}"
          },
          {
            "text": "Können Objekte von abstrakten Klassen instanziiert werden?",
            "options": [
              "Ja, sie können, wie normale Klassen instanziiert werden.",
              "Ja, aber nur in Ausnahmefällen.",
              "Ja, aber nur, wenn die abstrakte Methode nicht aufgerufen wird.",
              "Nein, es ist nicht möglich, Objekte von abstrakten Klassen zu instanziieren."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              3
            ],
            "explanation": "Eine abstrakte Klasse kann nicht instanziiert werden."
          },
          {
            "text": "Können Variablen mit dem Datentyp der abstrakten Klasse definiert werden?",
            "options": [
              "Ja, sie können, wie normale Variablen definiert werden.",
              "Ja, aber nur, wenn die abstrakte Klasse keine abstrakte Methode definiert.",
              "Ja, aber nur, wenn die abstrakte Klasse keine Variablen enthält.",
              "Nein, das ist nicht möglich."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Durch das Definieren von Variablen mit dem Datentyp einer abstrakten Klasse wird Polymorphismus ermöglicht."
          },
          {
            "text": "Was sind abstrakte Methoden?",
            "options": [
              "Methoden, die in einer abstrakten Klasse definiert sind und keine Rückgabe haben.",
              "Methoden, die in einer abstrakten Klasse definiert sind und keinen Namen haben.",
              "Methoden, die in einer abstrakten Klasse definiert sind und keinen Body haben.",
              "Es gibt keine abstrakten Methoden."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              2
            ],
            "explanation": "Eine abstrakte Methode besitzt keinen Body und kann somit auch nicht ausgeführt werden."
          },
          {
            "text": "Was gilt für abstrakte Methoden?",
            "options": [
              "Abstrakte Methoden müssen in einer nicht-abstrakten Subklasse redefiniert werden",
              "Abstrakte Methoden müssen in einer nicht-abstrakten Subklasse nicht redefiniert werden",
              "Abstrakte Methoden müssen in einer abstrakten Subklasse redefiniert werden",
              "Abstrakte Methoden können in einer abstrakten Subklasse redefiniert werden"
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              3
            ],
            "explanation": "In jeder nicht-abstrakten Subklasse muss die abstrakte Methode redefiniert werden, da sie potenziell aufgerufen werden kann. Dahingegen ist die Redefinition in einer abstrakten Subklasse nicht notwendig, da kein Aufruf möglich ist."
          },
          {
            "text": "Können nicht-abstrakte Methoden in einer abstrakten Klasse definiert werden?",
            "options": [
              "Ja, das ist möglich.",
              "Ja, aber nur, wenn die nicht-abstrakte Methode keinen Rückgabewert hat.",
              "Ja, aber nur, wenn die nicht-abstrakte Methode nicht aufgerufen wird.",
              "Nein, das ist nicht möglich."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Eine abstrakte Klasse kann auch nicht-abstrakte Methoden besitzen, beispielsweise um eine gemeinsame Methode der Subklassen zu definieren."
          },
          {
            "text": "Können abstrakte Methoden in nicht-abstrakten Klassen definiert werden",
            "options": [
              "Ja, das ist möglich.",
              "Ja, aber nur in bestimmten Klassen.",
              "Ja, aber nur, wenn die abstrakte Methode nicht aufgerufen wird.",
              "Nein, das ist nicht möglich."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              3
            ],
            "explanation": "Eine nicht-abstrakte Klasse kann keinen abstrakten Methoden besitzen, da der Aufruf zu einem Fehler führe würde."
          }
        ]
      }
    ]
  },
  {
    "title": "Zugriffssteuerung",
    "description": "Willkommen zum Quiz über das Thema „Zugriffssteuerung“!",
    "quizzes": [
      {
        "title": "Package-Organisation & Zugriffssteuerung",
        "questions": [
          {
            "text": "Was ist ein Package in Java?",
            "options": [
              "Eine Gruppierung von Klassen und Interfaces.",
              "Eine Datei mit dem Namen package.java, die die Metadaten eines Programms enthält.",
              "Eine spezielle Klasse, die verwendet wird, um Zugriff auf Klassen in einem anderen Package zu regeln."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Die Ordnung von Java-Files erfolgt mittels packaging. Dabei werden inhaltlich-zusammengehörende Klassen gruppiert."
          },
          {
            "text": "Wofür werden Packages verwendet?",
            "options": [
              "Packages ermöglichen, Klassen und Interfaces logisch zu gruppieren.",
              "Packages ermöglichen, den Zugriff auf Klassen und Interfaces zu steuern.",
              "Packages ermöglichen Vererbung."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              0,
              1
            ],
            "explanation": "Packaging erlaubt zum einen die logische Gruppierung von Java-Files und bietet zu anderen die Zugriffssteuerung durch den Access Modifier 'protected'."
          },
          {
            "text": "Was ist der Zweck von Zugriffssteuerung durch Access Modifier?",
            "options": [
              "Einschränkung des Zugriffs auf Klassen, Methoden und Variablen.",
              "Erleichterung des Zugriffs auf Klassen, Methoden und Variablen.",
              "Unterbindung des Zugriffs auf Klassen, Methoden und Variablen."
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Mittels Access Modifiern kan man den Zugriff auf Klassen, Methoden und Variablen auf unterschiedlichen Ebenen einschränken. Dabei unterscheidet man 'private', 'protected' und 'public'. Wenn man keinen expliziten Modifier angibt, wird der Default verwendet."
          },
          {
            "text": "Welcher Access Modifier gibt an, dass eine Klasse oder ein Variable nur innerhalb der aktuellen Klasse sichtbar sein sollte?",
            "options": [
              "public",
              "private",
              "protected",
              "keine Zugriffssteuerung angegeben"
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              1
            ],
            "explanation": "Alle Instanz-Variablen und -Methoden, die als private deklariert werden, können nur intern in dieser Klasse verwendet werden. Von außen ist kein Zugriff möglich."
          },
          {
            "text": "Welche Access Modifier gibt an, dass eine Methode oder ein Variable von überall aus sichtbar sein sollte?",
            "options": [
              "public",
              "private",
              "protected",
              "keine Zugriffssteuerung angegeben"
            ],
            "type": "SINGLE_CHOICE",
            "answer": [
              0
            ],
            "explanation": "Alle Instanz-Variablen und -Methoden, die als public deklariert werden, sind von überall aus zugänglich. Damit das OO-Konzept eingehalten wird, sollten nur IM public sein. Diese werden dann als öffentliche Schnittstelle zum objekt betrachtet."
          },
          {
            "text": "Was bedeutet es, wenn eine Variable als 'protected' deklariert wird?",
            "options": [
              "Die Variable ist nur innerhalb der Klasse sichtbar.",
              "Die Variable ist innerhalb des aktuellen Pakets sichtbar.",
              "Die Variable ist von überall aus sichtbar.",
              "Die Variable ist für Subklassen sichtbar."
            ],
            "type": "MULTIPLE_CHOICE",
            "answer": [
              1,
              3
            ],
            "explanation": "Alle Instanz-Variablen und -Methoden, die als protected deklariert werden, stehen sowohl im aktuellen Package als auch in allen definierten Subklassen zur Verfügung."
          }
        ]
      }
    ]
  }
]
