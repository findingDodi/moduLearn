{
  "id": 2,
  "title": "Variablen",
  "chapters": [
    {
      "title": "Variablen",
      "content": "Nun möchten wir Source-Code schreiben, um etwas mit Daten zu machen. Um im Sourcecode mit Daten umgehen zu können, müssen wir jeweils angeben\n- den Datentyp \n- den Ort im Speicher \n\n Den Datentypen hatten wir bereits als Kombination von Wertbereich und erlaubten Operationen kennengelernt. Die Kombination von Namen und Datentyp heißt Variable. Eine Variable wird definiert durch \n- ihren Datentyp \n- ihren Namen \n\nEine Variable heißt so, weil sich ihr Inhalt, ihr Wert im Programmablauf ändern kann. Ihr Wert ist variabel. \n\nDie Definition einer Variable in Java sieht so aus \n<Datentyp> <Name>; \n\nEin Semikolon ist in Java immer der Abschluss eines Befehls. Eindeutige Namen (Bezeichner) und gültige Datentypen sind müssen immer den geltenden Konventionen folgen. \n\nDatentypen müssen zueinander passen. Der Compiler übernimmt dabei die Prüfung der Zuweisung und der Operationen und Vergleiche. Datentypen passen zueinander, wenn die Wertebreiche übereinstimmen und wenn die auf den Werten definierten Operationen zueinander passen. \n\nDer Compiler gibt bereits vorab an, wenn es zu einem möglichen Datenverlust kommen kann. Das nennt sich Schisser-Prinzip oder auch Strong-Typing.\n\n\n"
    },
    {
      "title": "Referenz-Datentypen",
      "content": "Alle Datentypen, die wir bisher kennengelernt haben, haben einen festgelegten Wertebereich. Dafür ist der dafür benötigte Speicherplatz immer gleich groß (int: 4 Bytes, double: 8 bytes). Es gibt aber auch Datenarten, die keine feste, immer gleiche Länge haben. Die Länge der zulässigen Werte kann stark variieren. Einfaches und wichtiges Beispiel: Text (In Java heißt der Datentyp String).\nWie man auch an diesem Text sieht, gibt es kurze und lange Worte, sowie Sätze, Absätze und Dokumente. \n\nWenn eine Variable eines Datentyps nicht den \"eigentlichen\" Wert beinhaltet, sondern einen Verweis oder Pointer oder Referenz auf den \"eigentlichen\" Wert, wird der Datentyp allgemein als Referenz-Datentyp bezeichnet. \n\nNatürlich muss der Compiler beim Verwenden von Variablen eines\nReferenz-Datentypen (z.B. String) andere Befehle für die CPU erzeugen, als er das für Variable von primitiven Datentypen (int, boolean, ...) macht. Das weiß der Compiler aber, und macht das auch - weil er den Datentyp der Variablen kennt. \n\nWie wir oben bereits gesehen haben, kann man Referenz-Datentypen syntaktisch genauso verwenden, wie primitive Datentypen. Die Semantik, d.h. die Bedeutung der Verwendung einer Variablen von einem Referenz-Datentyp behandeln wir nun, aufgeteilt nach\n- Wert lesen und verwenden \n- Wert zuweisen, schreiben \n\nIn Java ist die Speicheradresse, die im Speicherplatz der Variablen eines Referenz-Datentyps steht, nicht zugänglich (anders als z.B. in C). Wenn wir im Folgenden vom \"Wert der Variable\" sprechen, dann können wir darunter immer den 'eigentlichen', d.h. den referenzierten Wert verstehen. Wenn wir von der Speicheradresse sprechen wollen, bezeichnen wir sie als 'Referenz'. \n\nUm den (referenzierten) Wert einer Variable eines Referenz-Datentyps zu verwenden, wird der Name der Variablen im Code geschrieben, wie bei primitiven Datentypen auch. \n\nBei der Zuweisung eines Werts an eine Variable gibt es allerdings einen wesentlichen Unterschied zwischen primitiven und Referenz-Datentypen. In Variablen von primitiven Datentypen wird eine Kopie des Wertes gespeichert (Call By Value), wohingegen in einer Variable eines Referenz-Datentyps nur die Referenz gespeichert wird (Call By Reference). \n\nJede Variable muss auf einen Wert gesetzt (initialisiert) sein, bevor man daraus einen Wert liest. Bei Referenz-Datentypen hat man die Möglichkeit, die Variable auf den Wert 'unbekannt, aber bestimmt noch nicht mit einem sinnvollen Wert besetzt' zu setzen. Der Wert ist damit 'definiert noch nicht auf einen richtigen Wert gesetzt'. Dieser Wert heißt null. Diesen Wert gibt es bei primitiven Datentypen nicht, da diese nur mit konkreten Werten initialisiert werden dürfen. Null ist dann nützlich, wenn man noch keinen konkreten Wert für die Variable kennt. Der Compiler kann daher nicht meckern, dass die Variable noch nicht initialisiert wurde und der Programmierer kann sich so eine Art TODO setzen, dass diese Variable noch keinen konkreten Wert besitzt. \n\nMittels einer Vergleichsoperation kann eine Variable auch auf null geprüft werden.\n\n\n"
    },
    {
      "title": "Arrays",
      "content": "Arrays sind eine effiziente Möglichkeit, gleichartige Elemente zu speichern und Code-Duplikation zu vermeiden.\nWenn in einem Programm viele ähnliche Variablen verwendet werden, führt das oft zu redundantem und fehleranfälligem Code.\nDurch die Nutzung von Arrays kann dieser Redundanz entgegengewirkt werden.\nEin Array ist eine Datenstruktur, die aus mehreren Elementen desselben Datentyps besteht.\nEin Array fasst alle seine Elemente unter einem Namen zusammen.\nZum Beispiel: int[] matrikelNummer; definiert ein Array für int-Werte.\nUm Speicherplatz für die Elemente des Arrays zu reservieren, verwendet man matrikelNummer = new int[5];,\nwas Speicherplatz für fünf int-Elemente allokiert.\nAuf die einzelnen Elemente eines Arrays greift man über Indizes zu, beginnend bei 0.\nZum Beispiel speichert matrikelNummer[2] = 765; den Wert 765 im dritten Element des Arrays.\nArrays sind Referenz-Datentypen, was bedeutet, dass Variablen nicht den Inhalt des Arrays selbst,\nsondern eine Referenz auf dessen Speicherplatz speichern.\nDadurch verweisen mehrere Array-Variablen auf dasselbe Array,\nund Änderungen über eine Variable sind in allen Variablen sichtbar.\nZur Laufzeit wird bei jedem Zugriff der Index geprüft, um sicherzustellen, dass er innerhalb der gültigen Bereichsgrenzen liegt.\nDie Länge eines Arrays kann mit <arrayname>.length ermittelt werden.\nBei der Initialisierung eines Arrays werden die Elemente automatisch auf einen Standardwert gesetzt,\nzum Beispiel 0 für int und false für boolean.\nArrays können auch mit Literalen initialisiert werden, zum Beispiel int[] teilnehmer = {101, 102, 103};,\nwobei direkt die Werte festgelegt werden.\nDiese Mechanismen machen Arrays zu einem mächtigen Werkzeug für die effiziente Verwaltung und Verarbeitung von Datensätzen.\n\n\n"
    },
    {
      "title": "2D-Arrays",
      "content": "In der Informatik gibt es unterschiedliche Arten, wie Parameter an Prozeduren und Funktionen übergeben werden können: als Referenz oder als Wert.\n Wenn ein Parameter eines primitiven Datentyps (z.B. int, double) übergeben wird, wird immer eine Kopie des Wertes übergeben.\n Dies bedeutet, dass Änderungen am Parameter innerhalb der Funktion keine Auswirkungen auf den ursprünglichen Wert haben.\n Ein Beispiel dafür ist die Prozedur reiheAusgebenAb(int startwert), die fünf aufeinanderfolgende Zahlen ab dem gegebenen Startwert ausgibt, ohne den ursprünglichen Startwert zu verändern.\n Bei Arrays hingegen, die Referenz-Datentypen sind, wird eine Referenz auf das Array übergeben.\n Dies bedeutet, dass Änderungen am Array innerhalb der Funktion auch nach außen hin sichtbar sind.\n Eine Prozedur wie arrayFuellenAb(int[] array, int startwert) zeigt dies deutlich: Das übergebene Array wird mit fortlaufenden Zahlen ab dem Startwert gefüllt, und diese Änderungen bleiben auch nach dem Funktionsaufruf bestehen.\n Ein weiteres Beispiel für den Umgang mit Referenz-Datentypen ist die Funktion erzeugeUndInitialsiereArrayDerGroesse(int groesse), die ein Array der angegebenen Größe erzeugt, mit einer Zahlenreihe füllt und eine Referenz auf das Array zurückgibt.\n Diese Referenz kann dann außerhalb der Funktion weiterverwendet werden.\n Dabei ist zu beachten, dass die Größe des Arrays zur Laufzeit bestimmt wird und nach der Erstellung nicht mehr verändert werden kann.\n Im Gegensatz zu primitiven Datentypen wird bei Referenz-Datentypen wie Arrays und Strings eine Referenz übergeben, wodurch die Funktion direkten Zugriff auf die ursprünglichen Daten hat und diese ändern kann.\n Dies gilt auch für Rückgabewerte: Eine Funktion, die einen Referenz-Datentyp zurückgibt, liefert eine Referenz, die auf das erzeugte oder bearbeitete Objekt zeigt.\n Zusammengefasst: Bei primitiven Datentypen werden Werte kopiert und innerhalb der Funktion verändert, ohne die Originalwerte zu beeinflussen.\n Bei Referenz-Datentypen hingegen wird eine Referenz übergeben, die es der Funktion ermöglicht, direkt auf die Originaldaten zuzugreifen und diese zu ändern.\n Diese Unterschiede sind wichtig, um zu verstehen, wie Daten in Funktionen und Prozeduren manipuliert und weiterverwendet werden können.\n\n\n"
    }
  ]
}