{
  "id": 2,
  "title": "Variablen",
  "chapters": [
    {
      "title": "Variablen",
      "content": "Nun möchten wir Source-Code schreiben, um etwas mit Daten zu machen. Um im Sourcecode mit Daten umgehen zu können, müssen wir jeweils angeben\n- den Datentyp \n- den Ort im Speicher \n\n Den Datentypen hatten wir bereits als Kombination von Wertbereich und erlaubten Operationen kennengelernt. Die Kombination von Namen und Datentyp heißt Variable. Eine Variable wird definiert durch \n- ihren Datentyp \n- ihren Namen \n\nEine Variable heißt so, weil sich ihr Inhalt, ihr Wert im Programmablauf ändern kann. Ihr Wert ist variabel. \n\nDie Definition einer Variable in Java sieht so aus \n<Datentyp> <Name>; \n\nEin Semikolon ist in Java immer der Abschluss eines Befehls. Eindeutige Namen (Bezeichner) und gültige Datentypen sind müssen immer den geltenden Konventionen folgen. \n\nDatentypen müssen zueinander passen. Der Compiler übernimmt dabei die Prüfung der Zuweisung und der Operationen und Vergleiche. Datentypen passen zueinander, wenn die Wertebreiche übereinstimmen und wenn die auf den Werten definierten Operationen zueinander passen. \n\nDer Compiler gibt bereits vorab an, wenn es zu einem möglichen Datenverlust kommen kann. Das nennt sich Schisser-Prinzip oder auch Strong-Typing."
    },
    {
      "title": "Referenz-Datentypen",
      "content": "Alle Datentypen, die wir bisher kennengelernt haben, haben einen festgelegten Wertebereich. Dafür ist der dafür benötigte Speicherplatz immer gleich groß (int: 4 Bytes, double: 8 bytes). Es gibt aber auch Datenarten, die keine feste, immer gleiche Länge haben. Die Länge der zulässigen Werte kann stark variieren. Einfaches und wichtiges Beispiel: Text (In Java heißt der Datentyp String).\nWie man auch an diesem Text sieht, gibt es kurze und lange Worte, sowie Sätze, Absätze und Dokumente. \n\nWenn eine Variable eines Datentyps nicht den \"eigentlichen\" Wert beinhaltet, sondern einen Verweis oder Pointer oder Referenz auf den \"eigentlichen\" Wert, wird der Datentyp allgemein als Referenz-Datentyp bezeichnet. \n\nNatürlich muss der Compiler beim Verwenden von Variablen eines\nReferenz-Datentypen (z.B. String) andere Befehle für die CPU erzeugen, als er das für Variable von primitiven Datentypen (int, boolean, ...) macht. Das weiß der Compiler aber, und macht das auch - weil er den Datentyp der Variablen kennt. \n\nWie wir oben bereits gesehen haben, kann man Referenz-Datentypen syntaktisch genauso verwenden, wie primitive Datentypen. Die Semantik, d.h. die Bedeutung der Verwendung einer Variablen von einem Referenz-Datentyp behandeln wir nun, aufgeteilt nach\n- Wert lesen und verwenden \n- Wert zuweisen, schreiben \n\nIn Java ist die Speicheradresse, die im Speicherplatz der Variablen eines Referenz-Datentyps steht, nicht zugänglich (anders als z.B. in C). Wenn wir im Folgenden vom \"Wert der Variable\" sprechen, dann können wir darunter immer den 'eigentlichen', d.h. den referenzierten Wert verstehen. Wenn wir von der Speicheradresse sprechen wollen, bezeichnen wir sie als 'Referenz'. \n\nUm den (referenzierten) Wert einer Variable eines Referenz-Datentyps zu verwenden, wird der Name der Variablen im Code geschrieben, wie bei primitiven Datentypen auch. \n\nBei der Zuweisung eines Werts an eine Variable gibt es allerdings einen wesentlichen Unterschied zwischen primitiven und Referenz-Datentypen. In Variablen von primitiven Datentypen wird eine Kopie des Wertes gespeichert (Call By Value), wohingegen in einer Variable eines Referenz-Datentyps nur die Referenz gespeichert wird (Call By Reference). \n\nJede Variable muss auf einen Wert gesetzt (initialisiert) sein, bevor man daraus einen Wert liest. Bei Referenz-Datentypen hat man die Möglichkeit, die Variable auf den Wert 'unbekannt, aber bestimmt noch nicht mit einem sinnvollen Wert besetzt' zu setzen. Der Wert ist damit 'definiert noch nicht auf einen richtigen Wert gesetzt'. Dieser Wert heißt null. Diesen Wert gibt es bei primitiven Datentypen nicht, da diese nur mit konkreten Werten initialisiert werden dürfen. Null ist dann nützlich, wenn man noch keinen konkreten Wert für die Variable kennt. Der Compiler kann daher nicht meckern, dass die Variable noch nicht initialisiert wurde und der Programmierer kann sich so eine Art TODO setzen, dass diese Variable noch keinen konkreten Wert besitzt. \n\nMittels einer Vergleichsoperation kann eine Variable auch auf null geprüft werden."
    },
    {
      "title": "Arrays",
      "content": "Da wir Code Duplikaten unter allen Umständen vermeiden wollen, müssen wir uns überlegen wie wir gleichartige Objekte effizient Speichern, um diese zu vermeiden. \n\nWie geht man nun um mit sehr vielen Variablen, die viel gemeinsam haben, wie z.B. die Bedeutung, den Namen (bis auf eine fortlaufende Nummer) und den Datentyp... \n\nZu diesem Zweck führen wir nun das Konzept Array ein. \n\nEin Array ist eine Datenstruktur, die aus einer Anzahl von Elementen besteht, die \n- die gleiche Bedeutung haben \n- den gleichen Datentyp haben. \nEin Array fasst alle seine Elemente unter 1 Namen zusammen. \n\nDie Syntax für die Definition einer Array-Variablen ist \n<Datentyp>[] <Name>; \n\nDie hier definierte Variable kann auf Arrays von beliebiger Größe zeigen, analog zu Variablen vom DT String. \nEin Array-Datentyp ist ein Referenz-Datentyp. \n\nAuf einzelne Elemente im Array kann man mithilfe des Index zugreifen - das heißt dann indizierter Zugriff. Der Index eines Elements ist seine \"Nummer\" bzw. \"Stelle\" im Array. \n\nEs können auch zweidimensionale Arrays erzeugt werden, indem man ein Array in einem anderen Array speichert. Das hat zum Beispiel den Vorteil, dass Koordinaten abgespeichert werden können."
    }
  ],
  "xPosition": 120,
  "yPosition": 505
}